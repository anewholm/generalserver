<xsl:stylesheet xmlns="http://www.w3.org/1999/xhtml" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xxx="http://general_server.org/xmlnamespaces/dummyxsl/2006" xmlns:exsl="http://exslt.org/common" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:repository="http://general_server.org/xmlnamespaces/repository/2006" xmlns:class="http://general_server.org/xmlnamespaces/class/2006" xmlns:user="http://general_server.org/xmlnamespaces/user/2006" name="interface_translators" response:server-side-only="true" version="1.0" extension-element-prefixes="dyn str regexp database server request flow debug repository user">
  <!-- this is a DXSL stylesheet
    <xsl:template contents are generated by the main @mode=gs_generate_XSL xsl:template
    they translate
      @gs:interface-mode to an <xsl:apply-templates @mode=[@gs:interface-mode]
    output:
      <xsl:template match="*" mode="gs_view_render">
        <xsl:param name="..."/>
        [...]
        <xsl:choose>
          <xsl:when test="@gs:interface-mode='summary'"><xsl:apply-templates select="." mode="summary" /></xsl:when>
          ...
          <xsl:otherwise><xsl:apply-templates select="." /></xsl:otherwise>
        </xsl:choose>
      </xsl:template>
    NOTE: <xsl:templates @meta:interface-template must accept the SAME xsl:parameters for a given @mode / @gs:interface-mode

    ALSO: we make a default template warning for un-handled interfaces:
      <xsl:template @match=* @mode=<interface>
        <div class=gs_warning>unhandled...
  -->
  <xsl:namespace-alias stylesheet-prefix="xxx" result-prefix="xsl"/>

  <xsl:template match="xsl:stylesheet" mode="gs_generate_XSL">
    <xsl:param name="gs_interface_class_templates" select="$gs_client_side_class_stylesheets/xsl:template[str:boolean(@meta:interface-template)]"/>
    <xsl:param name="gs_distinct_interface_templates" select="database:distinct($gs_interface_class_templates, '@mode')"/>

    <debug:server-message if="$gs_debug_url_steps" output="object:Request [{$gs_request/gs:message_type}] gs_distinct_interface_templates [{count($gs_distinct_interface_templates)}]"/>

    <xxx:template match="*" mode="gs_view_render">
      <xsl:comment>
        xsl:param defaults to a blank string
        further xsl:param declerations will receive the string and not default to the @select
        set the default to a blank node set with @meta:default-type=node-set
        note the BUG in LibXml2 that interprets the namespace-alias as an invalid param if this pre-xsl-statement is not here
      </xsl:comment>
      <xxx:param name="gs_interface_mode"/> <!--  complex-select="@gs:interface-mode" below -->
      <xsl:apply-templates select="database:distinct($gs_interface_class_templates/xsl:param, '@name')" mode="gs_interface_templates_param">
        <xsl:with-param name="gs_interface_class_templates" select="$gs_interface_class_templates"/>
      </xsl:apply-templates>

      <xsl:comment>main and complex default interface</xsl:comment>
      <xxx:variable name="gs_default_interface_fragment">
        <xxx:value-of select="$gs_interface_mode"/>
        <xxx:if test="not($gs_interface_mode)"><xxx:value-of select="@gs:interface-mode"/></xxx:if>
      </xxx:variable>
      <xxx:variable name="gs_default_interface" select="string($gs_default_interface_fragment)"/>
      <xxx:variable name="gs_main_interface_fragment">
        <xxx:value-of select="substring-before($gs_default_interface, '-')"/>
        <xxx:if test="not(contains($gs_default_interface, '-'))"><xxx:value-of select="$gs_default_interface"/></xxx:if>
      </xxx:variable>
      <xxx:variable name="gs_main_interface" select="string($gs_main_interface_fragment)"/>

      <xsl:comment>classes analysis and extended attributes</xsl:comment>
      <xxx:variable name="gs_html_identifier_class">
        <xxx:apply-templates select="." mode="gs_html_identifier_class">
          <xxx:with-param name="gs_interface_mode" select="$gs_default_interface"/>
        </xxx:apply-templates>
      </xxx:variable>

      <xsl:comment>begin @gs:interface-mode choose</xsl:comment>
      <xxx:choose>
        <xsl:apply-templates select="$gs_distinct_interface_templates[@mode]" mode="gs_interface_templates">
          <xsl:with-param name="gs_interface_class_templates" select="$gs_interface_class_templates"/>
        </xsl:apply-templates>
        
        <xxx:when test="not($gs_default_interface) or $gs_default_interface = 'default'">
          <xxx:apply-templates select=".">
            <xxx:with-param name="gs_html_identifier_class" select="$gs_html_identifier_class"/>
            <xxx:with-param name="gs_interface_mode" select="$gs_default_interface"/>
            <xsl:apply-templates select="database:distinct($gs_interface_class_templates[not(@mode)]/xsl:param, '@name')" mode="gs_interface_templates_with_param"/>
          </xxx:apply-templates>
        </xxx:when>
        
        <xxx:otherwise>
          <div class="gs-warning">[<xxx:value-of select="name()"/>] @meta:interface [<xxx:value-of select="$gs_default_interface"/>=<xxx:value-of select="$gs_main_interface"/>] not caught during @mode=gs_view_render</div>
        </xxx:otherwise>
      </xxx:choose>
    </xxx:template>

    <!-- TODO: unhandled interface @mode: XSL 2.0 only for space delimited @mode -->
    <!-- xxx:template match="/|@*|*">
      <xsl:attribute name="mode">
        <xsl:apply-templates select="$gs_distinct_interface_templates[@mode]" mode="gs_unhandled_interface_warning"/>
      </xsl:attribute>
      <div class="gs-warning">[<xxx:value-of select="name()"/>] unhandled interface</div>
    </xxx:template -->
  </xsl:template>

  <xsl:template match="xsl:template[@mode = 'default']" mode="gs_interface_templates"/>
  
  <xsl:template match="xsl:template" mode="gs_interface_templates">
    <xsl:param name="gs_interface_class_templates"/>
    
    <!-- TODO: check that $gs_main_interface is an NCName so that the template does not break -->
    <xsl:variable name="gs_main_interface" select="str:substring-before(@mode, '-')"/>

    <xxx:when test="$gs_main_interface='{@mode}'">
      <xxx:apply-templates select="." mode="{$gs_main_interface}">
        <xxx:with-param name="gs_html_identifier_class" select="$gs_html_identifier_class"/>
        <xxx:with-param name="gs_interface_mode" select="$gs_interface_mode"/>
        <xsl:apply-templates select="$gs_interface_class_templates[@mode = current()/@mode]/xsl:param" mode="gs_interface_templates_with_param"/>
      </xxx:apply-templates>
    </xxx:when>
  </xsl:template>

  <xsl:template match="xsl:param[@name='gs_html_identifier_class' or @name='gs_interface_mode' or @name='gs_main_interface']" mode="gs_interface_templates_param"/>
  <xsl:template match="xsl:param[@name='gs_html_identifier_class' or @name='gs_interface_mode']" mode="gs_interface_templates_with_param"/>

  <xsl:template match="xsl:param" mode="gs_interface_templates_param">
    <xsl:param name="gs_interface_class_templates"/>
    
    <xsl:if test="false()">DO NOT delete: BUG in LibXml2 that interprets the xxx:param namespace-alias as an invalid param if this pre-xsl-statement is not here</xsl:if>
    <xxx:param name="{@name}">
      <xsl:attribute name="select">
        <xsl:choose>
          <!-- document the default situation, which is a blank string -->
          <xsl:when test="not(@select)">''</xsl:when>
          <!-- copy the xsl:param default in the [first] target xsl:template, unless variable dependent -->
          <xsl:when test="not(contains(@select, '$'))"><xsl:value-of select="@select"/></xsl:when>
          <!-- default $variable dependent xsl:param to an empty node-set -->
          <xsl:otherwise>/..</xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
    </xxx:param>

    <!-- PERFORMANCE: expensive test for different global @select defaults for this xsl:param -->
    <xsl:variable name="gs_similar_params" select="$gs_interface_class_templates/xsl:param[@name = current()/@name]"/>
    <xsl:if test="$gs_similar_params[not(string(@select) = string(current()/@select))]">
      <debug:server-message output="different @select defaults for xsl:param [${@name}] ({@xml:id}) in @interface-mode translation DXSL" type="warning"/>
      <xsl:comment>
        <xsl:text>WARNING: different @select defaults for [$</xsl:text>
          <xsl:value-of select="@name"/>
          <xsl:if test="@xml:id"> (<xsl:value-of select="@xml:id"/>)</xsl:if>
        <xsl:text>]:</xsl:text>
        <xsl:value-of select="$gs_newline"/>
        <xsl:apply-templates select="$gs_similar_params" mode="gs_interface_templates_different_selects"/>
      </xsl:comment>
    </xsl:if>
  </xsl:template>

  <xsl:template match="xsl:param" mode="gs_interface_templates_with_param">
    <xxx:with-param name="{@name}" select="${@name}"/>
  </xsl:template>

  <xsl:template match="xsl:param" mode="gs_interface_templates_different_selects">
    <xsl:text>  </xsl:text>
    <xsl:if test="not(@xml:id)">(no @xml:id)</xsl:if>
    <xsl:value-of select="@xml:id"/>
    <xsl:text> </xsl:text>
    <xsl:if test="../@mode">
      <xsl:text>in @mode=</xsl:text>
      <xsl:value-of select="../@mode"/>
    </xsl:if>
    <xsl:if test="not(../@mode)">in default @mode</xsl:if>
    <xsl:text>: </xsl:text>
    
    <xsl:if test="not(@select)">(no @select which defaults to a '' string)</xsl:if>
    <xsl:if test="@select"><xsl:value-of select="@select"/></xsl:if>
    <xsl:value-of select="$gs_newline"/>
  </xsl:template>
  
  <!-- xsl:template match="xsl:template" mode="gs_unhandled_interface_warning">
    <xsl:if test="not(position()=1)"> </xsl:if>
    <xsl:value-of select="str:substring-before(@mode, '-')"/>
  </xsl:template -->
</xsl:stylesheet>
