<xsl:stylesheet xmlns="http://www.w3.org/1999/xhtml" xmlns:xxx="http://general_server.org/xmlnamespaces/dummyxsl/2006" xmlns:exsl="http://exslt.org/common" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:repository="http://general_server.org/xmlnamespaces/repository/2006" xmlns:class="http://general_server.org/xmlnamespaces/class/2006" xmlns:user="http://general_server.org/xmlnamespaces/user/2006" name="class_introspection" response:server-side-only="true" version="1.0" extension-element-prefixes="dyn str regexp database server request flow debug repository user">
  <!-- this is a DXSL stylesheet
    its xsl:template contents are generated by the main @mode=gs_generate_XSL xsl:template
    they translate an element to gs_classes and gs_base_classes strings
    str:list() is used because this is code and we cannot traverse an XSLT_TREE_FRAGMENT on the client side
    output:
      <xsl:template match="interface:Frame" mode="gs_classes_string">Frame</xsl:template>
      <xsl:template match="interface:Frame" mode="gs_base_classes_string">DatabaseObject,BaseObject, ...</xsl:template>
      [<xsl:template match="interface:Frame" mode="gs_html_container">ul</xsl:template>]
      [<xsl:template match="interface:Frame" mode="gs_debug">yes</xsl:template>]
  -->
  <xsl:namespace-alias stylesheet-prefix="xxx" result-prefix="xsl"/>

  <xsl:template match="xsl:stylesheet" mode="gs_generate_XSL">
    <xsl:param name="gs_client_element_classes" select="$gs_website_classes[@elements]"/>

    <debug:server-message if="$gs_debug_url_steps" output="object:Request [{$gs_request/gs:message_type}] gs_element_classes [{count($gs_client_element_classes)}]"/>

    <xsl:comment>class attribute defaults</xsl:comment>
    <xxx:template match="*" mode="gs_html_container"/>
    <xxx:template match="*" mode="gs_debug"/>

    <xsl:comment>classes</xsl:comment>
    <xsl:apply-templates select="$gs_client_element_classes" mode="gs_classes_templates">
      <xsl:sort select="database:base-class-count()" data-type="number"/>
    </xsl:apply-templates>
    
    <xsl:comment>base classes</xsl:comment>
    <xsl:apply-templates select="$gs_client_element_classes[class:*]" mode="gs_base_classes_templates">
      <xsl:sort select="database:base-class-count()" data-type="number"/>
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="class:*" mode="gs_classes_templates">
    <!-- TODO: combine templates that work on similar elements? -->
    <xsl:variable name="gs_this_class_elements" select="database:class-template-match()"/>
    <xxx:template match="{$gs_this_class_elements}" mode="gs_classes_string" meta:base-class-count="{database:base-class-count()}"><xsl:value-of select="local-name()"/></xxx:template>
  </xsl:template>

  <xsl:template match="class:*" mode="gs_base_classes_templates">
    <xsl:variable name="gs_base_classes" select="database:base-classes-all(local-name())"/>
    <xsl:variable name="gs_this_class_elements" select="database:class-template-match()"/>
    <xsl:variable name="gs_all_classes" select=".|$gs_base_classes"/>

    <!-- str:list() is used because this is code and we cannot traverse an XSLT_TREE_FRAGMENT on the client side -->
    <xxx:template match="{$gs_this_class_elements}" mode="gs_base_classes_string" meta:base-class-count="{database:base-class-count()}"><xsl:value-of select="str:list($gs_base_classes)"/></xxx:template>

    <!-- optional -->
    <xsl:variable name="gs_html_container" select="$gs_all_classes[@html-container][1]/@html-container"/>
    <xsl:if test="$gs_html_container"><xxx:template match="{$gs_this_class_elements}" mode="gs_html_container"><xsl:value-of select="$gs_html_container"/></xxx:template></xsl:if>

    <xsl:variable name="gs_debug" select="$gs_all_classes[@debug][1]/@debug"/>
    <xsl:if test="$gs_debug"><xxx:template match="{$gs_this_class_elements}" mode="gs_debug"><xsl:value-of select="$gs_debug"/></xxx:template></xsl:if>
  </xsl:template>
</xsl:stylesheet>
